<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>認為變更偵測是深度優先與廣度優先的人通常都是對的 › 翻譯蒟蒻</title>
  <meta name="author" content="Brian">
  
  <meta name="description" content="原文：https://angular.love/he-who-thinks-change-detection-is-depth-first-and-he-who-thinks-its-breadth-first-are-both-usually-right
認為變更檢測是深度優先的人，與認為變更檢測是廣度優先的人，通常都是對的我曾經被問到 Angular 中的變更偵測是深度優先還是廣度優先。這基本上意味著 Angular 是先檢查當前元件的兄弟元件（廣度優先），還是先檢查其子元件（深度優先）。我之前沒有考慮過這個問題，所以我只是憑直覺和對內部機制的了解來回答。我宣稱它是深度優先的。後來，為了驗證我的斷言，我建立了一個元件樹，並在 ngDoCheck 鉤子中加入了一些日誌記錄邏輯：">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="認為變更偵測是深度優先與廣度優先的人通常都是對的"/>
  <meta property="og:site_name" content="翻譯蒟蒻"/>

  
    <meta property="og:image" content=""/>
  

  <link href="/TranslationKonjac/favicon.png" rel="icon">
  <link rel="alternate" href="/TranslationKonjac/atom.xml" title="翻譯蒟蒻" type="application/atom+xml">
  <link rel="stylesheet" href="/TranslationKonjac/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  <header id="header"><div class="meta inner">
  <h1><a href="/TranslationKonjac/">翻譯蒟蒻</a></h1>
  <h2><a href="/TranslationKonjac/"></a></h2>
  <nav id="main-nav">
    <ul>
      
    </ul>
    <div class="clearfix"></div>
  </nav>
</div>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title">認為變更偵測是深度優先與廣度優先的人通常都是對的</h1>
  

      
        <time datetime="2025-01-13T08:40:56.000Z">2025-01-13</time>
      
    </header>
    <div class="entry">
      
        <p>原文：<a target="_blank" rel="noopener" href="https://angular.love/he-who-thinks-change-detection-is-depth-first-and-he-who-thinks-its-breadth-first-are-both-usually-right">https://angular.love/he-who-thinks-change-detection-is-depth-first-and-he-who-thinks-its-breadth-first-are-both-usually-right</a></p>
<h1 id="認為變更檢測是深度優先的人，與認為變更檢測是廣度優先的人，通常都是對的"><a href="#認為變更檢測是深度優先的人，與認為變更檢測是廣度優先的人，通常都是對的" class="headerlink" title="認為變更檢測是深度優先的人，與認為變更檢測是廣度優先的人，通常都是對的"></a>認為變更檢測是深度優先的人，與認為變更檢測是廣度優先的人，通常都是對的</h1><p>我曾經被問到 <a target="_blank" rel="noopener" href="https://angular.love/these-5-articles-will-make-you-an-angular-change-detection-expert/">Angular 中的變更偵測</a>是深度優先還是廣度優先。這基本上意味著 Angular 是先檢查當前元件的兄弟元件（廣度優先），還是先檢查其子元件（深度優先）。我之前沒有考慮過這個問題，所以我只是憑直覺和對內部機制的了解來回答。我宣稱它是深度優先的。後來，為了驗證我的斷言，我建立了一個元件樹，並在 <code>ngDoCheck</code> 鉤子中加入了一些日誌記錄邏輯：</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Component(&#123;</span><br><span class="line">    selector: &#x27;r-comp&#x27;,</span><br><span class="line">    template: `&#123;&#123;addRender()&#125;&#125;`</span><br><span class="line">&#125;)</span><br><span class="line">export class RComponent &#123;</span><br><span class="line">    ngDoCheck() &#123;</span><br><span class="line">        // 依序保存所有呼叫並記錄到控制台</span><br><span class="line">        calls.ngDoCheck.push(&#x27;R&#x27;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>令我驚訝的是，結果顯示某些兄弟元件先被檢查，如下圖所示：</p>
<p><img src="https://wp.angular.love/wp-content/uploads/2024/07/content-image1-79.gif" alt="Image 16"></p>
<p>所以你在這裡看到 Angular 先檢查 <code>K</code>，然後是 <code>V</code>、<code>L</code>，然後是 <code>C</code>，依此類推。那麼我錯了嗎？它真的是一個廣度優先的演算法嗎？嗯，不完全是。首先要注意的是，上面的表示不是一個正確的廣度優先演算法。該演算法的傳統實作檢查<strong><strong>同一層級上的所有兄弟元件</strong></strong>，而在上圖中，你可以看到該演算法確實檢查了 <code>L</code> 和 <code>C</code> 兄弟元件，但它並沒有檢查 <code>X</code> 和 <code>F</code>，而是向下檢查 <code>J</code> 和 <code>O</code>。此外，廣度優先圖遍歷演算法的實作是明確定義的，但我無法在原始碼中找到它。因此，我決定進行另一個實驗，並在變更偵測評估表達式時呼叫的自訂函數中加入日誌記錄邏輯：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Component(&#123;</span><br><span class="line">    selector: &#x27;r-comp&#x27;,</span><br><span class="line">    template: `&#123;&#123;addRender()&#125;&#125;`</span><br><span class="line">&#125;)</span><br><span class="line">export class RComponent &#123;</span><br><span class="line">    addRender() &#123;</span><br><span class="line">        calls.render.push(&#x27;R&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這次我得到了不同的結果：</p>
<p><img src="https://wp.angular.love/wp-content/uploads/2024/07/content-image2-71.gif" alt="Image 17"></p>
<p>這是一個正確的深度優先圖遍歷演算法。那麼這裡發生了什麼事？其實很簡單，讓我來解釋一下。</p>
<h2 id="變更偵測操作"><a href="#變更偵測操作" class="headerlink" title="變更偵測操作"></a>變更偵測操作</h2><p>為了了解行為上的差異，我們需要看看變更偵測機制在檢查元件時執行的操作。如果你讀過 <a target="_blank" rel="noopener" href="https://angular.love/these-5-articles-will-make-you-an-angular-change-detection-expert/">我其他關於變更偵測的文章</a>，你可能知道變更偵測執行的主要操作如下：</p>
<ul>
<li>更新子元件的屬性</li>
<li>在<strong><strong>子元件上</strong></strong>呼叫 <code>NgOnChanges</code> 和 <a target="_blank" rel="noopener" href="https://angular.love/if-you-think-ngdocheck-means-your-component-is-being-checked-read-this-article/"><code>NgDoCheck</code></a> 生命周期鉤子</li>
<li>在<strong><strong>當前元件上</strong></strong>更新 DOM</li>
<li><strong><strong>對子元件執行變更偵測</strong></strong></li>
</ul>
<p>我上面重點標示了一個有趣的細節 — 當 Angular 檢查當前元件時，它會呼叫<strong><strong>子元件上</strong></strong>的生命週期鉤子，但會為<strong><strong>當前元件</strong></strong>渲染 DOM。這是一個非常重要的區別。這正是使得如果我們將日誌記錄放入 <code>NgDoCheck</code> 鉤子中，會讓人覺得該演算法以廣度優先方式運作的原因。當 Angular 檢查一個當前元件時，它會呼叫其所有作為兄弟元件的子元件的生命週期鉤子。假設 Angular 現在檢查 <code>K</code> 元件，並在 <code>L</code> 和 <code>C</code> 上呼叫 <code>NgDoCheck</code> 生命周期鉤子。因此，我們得到以下結果：</p>
<p><img src="https://wp.angular.love/wp-content/uploads/2024/07/content-image3-48.gif" alt="Image 18"></p>
<p>看起來像是廣度優先演算法。然而，請記住，Angular 仍在檢查 <code>K</code> 元件的過程中。因此，在完成 <code>K</code> 元件的所有操作後，它不會像廣度優先實作那樣繼續檢查兄弟元件 <code>V</code>。相反，它會繼續檢查 <code>K</code> 的子元件 <code>L</code>。這是變更偵測演算法的深度優先實作。而且，我們現在知道它會在 <code>J</code> 和 <code>O</code> 元件上呼叫 <code>ngDoCheck</code>，這正是發生的情況：</p>
<p><img src="https://wp.angular.love/wp-content/uploads/2024/07/content-image4-53.gif" alt="Image 19"></p>
<p>所以，最後，我的直覺並沒有讓我失望。變更偵測機制在內部是以深度優先方式實作的，但會先在兄弟元件上呼叫 <code>ngDoCheck</code> 生命周期鉤子。順帶一提，我已經在 <a target="_blank" rel="noopener" href="https://angular.love/if-you-think-ngdocheck-means-your-component-is-being-checked-read-this-article/">如果你認為 `ngDoCheck` 表示你的元件正在被檢查 — 請閱讀這篇文章</a> 中深入描述了這個邏輯。</p>
<h3 id="Stackblitz-演示"><a href="#Stackblitz-演示" class="headerlink" title="Stackblitz 演示"></a>Stackblitz 演示</h3><p><a target="_blank" rel="noopener" href="https://stackblitz.com/edit/depth-or-breadth-first">這裡</a> 你可以看到在不同位置記錄日誌的演示。</p>

      
    </div>
      
      <footer>
        
        
        
  <div class="addthis addthis_toolbox addthis_default_style">
    
      <a class="addthis_button_facebook_like" fb:like:layout="button_count"></a>
    
    
      <a class="addthis_button_tweet"></a>
    
    
      <a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
    
    
      <a class="addthis_button_pinterest_pinit" pi:pinit:layout="horizontal"></a>
    
    <a class="addthis_counter addthis_pill_style"></a>
  </div>
  <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js"></script>

      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>


<section id="comment">
  
</section>


</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜尋">
    <input type="hidden" name="q" value="site:viaje9.github.io">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">最新文章</h3>
  <ul class="entry">
    
      <li>
        <a href="/TranslationKonjac/2025/04/05/zh-tw-How-to-Get-Rich/">如何致富（不靠運氣）</a>
      </li>
    
      <li>
        <a href="/TranslationKonjac/2025/02/17/zh-tw-change-detection-and-component-trees-in-angular-applications/">Angular 應用程式中的變更偵測與元件樹</a>
      </li>
    
      <li>
        <a href="/TranslationKonjac/2025/01/20/zh-tw-local-change-detection-and-angular-signals-in-templates-in-details/">局部變更偵測與 Angular Signals 在模板中的詳細應用</a>
      </li>
    
      <li>
        <a href="/TranslationKonjac/2025/01/19/zh-tw-running-change-detection-components-tree/">執行變更偵測 – 元件樹</a>
      </li>
    
      <li>
        <a href="/TranslationKonjac/2025/01/13/zh-tw-change-detection-big-picture-unidirectional-data-flow/">變更偵測大觀 – 單向數據流</a>
      </li>
    
  </ul>
</div>


  

  
</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2025 Brian
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>



</body>
</html>

